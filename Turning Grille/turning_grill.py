# -*- coding: utf-8 -*-
"""Turning Grill.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1jFjmrhTQBb7mT0AvswGdCB3S-KZHi-jn
"""

import numpy as np
import math

def read_message(message,size):
  final_message=""
  for i in range(size):
    for j in range(size):
      final_message=final_message+message[i][j]
      
  print(final_message)

def read_message2(message,size):
  final_message=""
  for i in range(size):
      final_message=final_message+message[i]
      
  print(final_message)

print("Welcome to the Playfair Cipher app!")
choice=input("Insert 1 for ciphering a message or 0 for deciphering a message\n")


if choice == '1':#Encrypt
  message=input("Please insert the message to be ciphered: ")
  size=input("Insert size of grille: ")
  size=int(size)
  direction=input("Insert 1 for left rotation, 0 for right rotation: ")
  holes=input("Insert number of holes: ")

  key=np.zeros((size,size))
  cryptedMessage=np.zeros((size,size))

  #Put holes in key, represented by a 1
  for i in range(int(holes)): 
    coord=input("Insert x and y coordinates for hole "+str(i)+": ")
    k=np.fromstring(coord,dtype=int, sep=',')
    k=np.reshape(k,(2,1))
    key[k[0],k[1]]=1
  print("Key: ")
  print(key)

  #Format message
  message=message.replace(' ','')
  message=message.lower()

  while len(message)<size*size:
    message=message+"x"

  counter=0
  rotated=np.zeros((size,size))
  cryptedMessage = np.arange(size*size) #Create array numpy
  cryptedMessage = list(map(lambda x: '', cryptedMessage)) #Convert array to numpy so it can admit strings
  cryptedMessage = np.array(cryptedMessage).reshape((size,size)) #Shape the array to matrix

  #Right or left rotation
  if direction=='1':
    for i in range(4):
      rotated=np.rot90(key,i)#Rotate the key counter-clockwise
      for j in range(size):
        for x in range(size):
          if rotated[j][x]==1: #See if the coordinates have a hole
            cryptedMessage[j][x]=message[counter] #Put the corresponding letter in the corresponding coordinates
            counter=counter+1
    
  else:
    
    for i in range(4):
      rotated=np.rot90(key,i,axes=[1,0]) #Rotate the key clockwise
      for j in range(size):
        for x in range(size):
          if rotated[j][x]==1: #See if the coordinates have a hole
            cryptedMessage[j][x]=message[counter] #Put the corresponding letter in the corresponding coordinates
            counter=counter+1    
    
  read_message(cryptedMessage,size) #Read the message without the array format
  
elif choice=='0':#Decrypt
  message=input("Please insert the message to be deciphered: ")
  size=input("Insert size of grille: ")
  size=int(size)
  direction=input("Insert 1 for left rotation, 0 for right rotation: ")
  holes=input("Insert number of holes: ")

  key=np.zeros((size,size))

  #Put holes in key represented by a 1
  for i in range(int(holes)): 
    coord=input("Insert x and y coordinates for hole "+str(i)+": ")
    k=np.fromstring(coord,dtype=int, sep=',')
    k=np.reshape(k,(2,1))
    key[k[0],k[1]]=1
  print("Key: ")
  print(key)

  #Format message
  message=message.replace(' ','')
  message=message.lower()

  cryptedMessage = np.arange(size*size) #Create array numpy
  cryptedMessage = list(map(lambda x: '', cryptedMessage)) #Convert array to numpy so it can admit strings
  cryptedMessage = np.array(cryptedMessage).reshape((size,size)) #Shape the array to matrix

  #Put the crypted message in the matrix
  counter=0
  for i in range(size):
    for j in range(size):
      cryptedMessage[i][j]=message[counter]
      counter=counter+1

  decryptedMessage = np.arange(size*size) #Create array numpy
  decryptedMessage = list(map(lambda x: '', decryptedMessage)) #Convert array to numpy so it can admit strings

  counter=0
  if direction=='1':
    for i in range(4):
      rotated=np.rot90(key,i) #Rotate the key counter-clockwise
      for j in range(size):
        for x in range(size):
          if rotated[j][x]==1: #See if the coordinates have a hole
            decryptedMessage[counter]=cryptedMessage[j][x] #Put the letter from the matrix in the coded message
            counter=counter+1
    
  else:
    for i in range(4):
      rotated=np.rot90(key,i,axes=[1,0]) #Rotate the key clockwise
      for j in range(size):
        for x in range(size):
          if rotated[j][x]==1: #See if the coordinates have a hole
            decryptedMessage[counter]=cryptedMessage[j][x] #Put the letter from the matrix in the coded message
            counter=counter+1
  
  read_message2(decryptedMessage,size*size) #Read the message without the array format

else:
   print("Please insert a valid option")