# -*- coding: utf-8 -*-
"""Hill Cypher.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1FLdrq0ekDybtgnmMbCN404Le6txcQCYp
"""

from re import A
import numpy as np
import math

letters=['a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i', 'j', 'k', 'l', 'm',
         'n', 'o', 'p', 'q', 'r', 's', 't', 'u', 'v', 'w', 'x', 'y', 'z']

def create_pairs(message):
  message=np.array(list(message))

  #Loop through the message by pairs
  for i in range(int(message.shape[0]/2)):
    if message[2*i] == message[2*i+1]: #If the pair has the same letter, insert an x
      message=np.insert(message, 2*i+1, 23)
      
  if message.shape[0]%2 != 0: #If the length of the message is odd, insert an x at the end
    message=np.concatenate((message,[23]),axis=0)

  message=message.reshape((-1,2)) #Reshape the message to an array of pairs
  #print(message)
  return message

def char_to_number(message):
  messageNumber=np.arange(int(len(message)))
  for i in range(len(message)):
    letter_number=np.where(letters[:]==message[i])
    letter_number=list(map(int,letter_number))

    messageNumber[i]=letter_number[0]
  return messageNumber


def modular_inverse(k):
  det_k=int(np.linalg.det(k))
  if(det_k!=0):
    #adj_k=np.linalg.inv(k)*det_k 
    #adj_k=np.floor(adj_k)
    adj_k=adjacency_matrix(k)
    mcd=euclides(det_k,26)
    modular_inverse1=mcd[1]*adj_k
    modular_inverse1=modular_inverse1%26
    #modular_inverse=np.floor(modular_inverse)
    #modular_inverse=modular_inverse.astype(int)
    return modular_inverse1
  else:
    print("The inserted matrix does not have an inverse")
    return 0

def euclides(a,b):
  if b==0:
    return[a,1,0]
  else:
    q=math.floor(a/b)
    result=euclides(b,a%b)
    y=result[1]-q*result[2]
    result[1]=result[2]
    result[2]=y
    return result

def adjacency_matrix(k):
  q=np.copy(k)
  q[0][0]=k[1][1]
  q[0][1]=-k[0][1]
  q[1][0]=-k[1][0]
  q[1][1]=k[0][0]
  return q

def multiply_matrixes(message,k):
  crypted_message=np.copy(message)
  for i in range(len(message)):
    #multiplication=message[i]*k
    multiplication=np.matmul(message[i],k)
    crypted_message[i][0]=multiplication[0]%26
    crypted_message[i][1]=multiplication[1]%26
  
  return crypted_message


def read_message(message):
  final_message=""
  c=0
  for i in range(len(message)):
    for j in range(2):
      final_message=final_message+letters[message[i][j]]
      

  print(final_message)

print("Welcome to the Playfair Cipher app!")
choice=input("Insert 1 for ciphering a message or 0 for deciphering a message\n")


if choice == '1':#Encrypt
  message=input("Please insert the message to be ciphered: ")
  a=input("Please insert numbers of the matrix 2x2 to decode the message: ")

  message=message.lower()

  k=np.fromstring(a,dtype=int, sep=',')
  k=np.reshape(k,(2,2))

  letters=np.array(letters)
  message=char_to_number(message)
  message=create_pairs(message)

  crypted_message=multiply_matrixes(message,k)
    
  #print(crypted_message)
  read_message(crypted_message)
elif choice=='0':#Decrypt
  message=input("Please insert the message to be deciphered: ")
  a=input("Please insert numbers of the matrix 2x2 to decode the message: ")

  message=message.lower()

  a=np.fromstring(a,dtype=int, sep=',')
  a=np.reshape(a,(2,2))
  k=modular_inverse(a)

  letters=np.array(letters)
  message=char_to_number(message)
  message=create_pairs(message)

  crypted_message=multiply_matrixes(message,k)
    
  #print(crypted_message)
  read_message(crypted_message)
else:
  print("Please insert a valid option")

import math
import numpy as np

def euclides(a,b):
  if b==0:
    return[a,1,0]
  else:
    q=math.floor(a/b)
    result=euclides(b,a%b)
    y=result[1]-q*result[2]
    result[1]=result[2]
    result[2]=y
    return result


def modular_inverse(k):
  det_k=int(np.linalg.det(k))
  if(det_k!=0):
    print(det_k)
    adj_k=np.linalg.inv(k)*det_k 
    mcd=euclides(det_k,26)
    modular_inverse=mcd[1]*adj_k
    modular_inverse=modular_inverse%26
    return modular_inverse
  else:
    print("The inserted matrix does not have an inverse")
    return 0

a=input("Ingrese matriz: ")
a=np.fromstring(a,dtype=int, sep=',')
a=np.reshape(a,(2,2))
print(modular_inverse(a))